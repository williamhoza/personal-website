<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><script src="/mathjax-config.js"></script><script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async=""></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Typically-Correct Derandomization for Small Time and Space</title><link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="/main.css"><meta property="og:title" content="Typically-Correct Derandomization for Small Time and Space"></head><body><span style="display:none;">
      \(\renewcommand{\epsilon}{\varepsilon}\)
      \(\renewcommand{\hat}{\widehat}\)
      \(\DeclareMathOperator*{\E}{\mathbb{E}}\)
    </span><main><article><p><a href="/tcs/">Back to list of papers</a></p><hr><h1>Typically-Correct Derandomization for Small Time and Space</h1><p>By William M. Hoza</p><hr><p>Read the paper: <a href="https://arxiv.org/abs/1711.00565">arXiv</a><span> • </span><a href="https://doi.org/10.4230/LIPIcs.CCC.2019.9">CCC proceedings</a></p><details><summary>Abstract (for specialists)</summary><div class="indent"><p>
  Suppose a language \(L\) can be decided by a bounded-error randomized algorithm that runs in space \(S\) and time \(n \cdot \text{poly}(S)\). We give a randomized algorithm for \(L\) that still runs in space \(O(S)\) and time \(n \cdot \text{poly}(S)\) that uses only \(O(S)\) random bits; our algorithm has a low failure probability on all but a negligible fraction of inputs of each length. As an immediate corollary, there is a deterministic algorithm for \(L\) that runs in space \(O(S)\) and succeeds on all but a negligible fraction of inputs of each length. We also give several other complexity-theoretic applications of our technique.
</p>
</div></details><details><summary>Not-so-abstract (for curious outsiders)</summary><p>                  ⚠️ <em>This summary might gloss over some important details.</em></p><div class="indent"><p>
  A "randomized" algorithm tosses coins to make decisions, whereas a "deterministic" algorithm doesn't use any randomness. Most theoretical computer scientists believe that if a problem can be solved by a randomized algorithm, then it can also be solved by a deterministic algorithm that uses about the same amount of time and memory. But nobody knows how to prove it. In this paper, we prove that if a problem can be solved by a fast randomized algorithm, then it can also be solved by a deterministic algorithm that uses about the same amount of memory, with the caveat that the deterministic algorithm might give the wrong answer on a tiny fraction of inputs.
</p>
</div></details><p>Manuscript posted online in November 2017; appeared at CCC in July 2019. The arXiv version and the CCC proceedings version are the same except for formatting.</p><hr><p>Expository material:</p><div class="expository">
  <iframe src="https://www.youtube.com/embed/PxiCmJG4h5E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  <p>
    <a href="https://youtu.be/PxiCmJG4h5E">Video</a> from my presentation at CCC (July 2019). Here are the <a href="CCC-slides.pdf">slides</a> from that presentation. See also these <a href="israel-slides.pdf">longer slides</a> from my presentation at HUJI's Theory of Computer Science Seminar (March 2018); I used very similar slides for my presentations at Weizmann Institute's Foundations of Computer Science Seminar (March 2018) and TAU's Theory of Computation Seminar (March 2018).
  </p>
</div>
<hr>  </article></main><script data-goatcounter="https://williamhoza.goatcounter.com/count" src="//gc.zgo.at/count.js" async=""></script></body></html>