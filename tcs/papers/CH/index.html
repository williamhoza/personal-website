<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><script src="/mathjax-config.js"></script><script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async=""></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Hitting Sets Give Two-Sided Derandomization of Small Space</title><link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="/main.css"><meta property="og:title" content="Hitting Sets Give Two-Sided Derandomization of Small Space"></head><body><span style="display:none;">
      \(\renewcommand{\epsilon}{\varepsilon}\)
      \(\renewcommand{\hat}{\widehat}\)
      \(\DeclareMathOperator*{\E}{\mathbb{E}}\)
    </span><main><article><p><a href="/tcs/">Back to list of papers</a></p><hr><h1>Hitting Sets Give Two-Sided Derandomization of Small Space</h1><p>By Kuan Cheng and William M. Hoza</p><hr><p>Read the paper: <a href="https://eccc.weizmann.ac.il/report/2020/016/">ECCC</a><span> ‚Ä¢ </span><a href="https://doi.org/10.4230/LIPIcs.CCC.2020.10">CCC proceedings</a></p><details><summary>Abstract (for specialists)</summary><div class="indent"><p>
  A hitting set is a "one-sided" variant of a pseudorandom generator (PRG), naturally suited to derandomizing algorithms that have one-sided error. We study the problem of using a given hitting set to derandomize algorithms that have two-sided error, focusing on space-bounded algorithms. For our first result, we show that if there is a log-space hitting set for polynomial-width read-once branching programs (ROBPs), then not only does \(\mathbf{L}=\mathbf{RL}\), but \(\mathbf{L}=\mathbf{BPL}\) as well. This answers a question raised by Hoza and Zuckerman (FOCS 2018).
</p>

<p>
  Next, we consider constant-width ROBPs. We show that if there are log-space hitting sets for constant-width ROBPs, then given black-box access to a constant-width ROBP \(f\), it is possible to deterministically estimate \(\mathbb{E}[f]\) to within \(\pm \varepsilon\) in space \(O(\log(n/\varepsilon))\). Unconditionally, we give a deterministic algorithm for this problem with space complexity \(O(\log^2 n+ \log(1/\varepsilon))\), slightly improving over previous work.
</p>

<p>
  Finally, we investigate the limits of this line of work. Perhaps the strongest reduction along these lines one could hope for would say that for every explicit hitting set, there is an explicit PRG with similar parameters. In the setting of constant-width ROBPs over a large alphabet, we prove that establishing such a strong reduction is at least as difficult as constructing a good PRG outright. Quantitatively, we prove that if the strong reduction holds, then for every constant \(\alpha > 0\), there is an explicit PRG for constant-width ROBPs with seed length \(O(\log^{1+ \alpha} n)\). Along the way, unconditionally, we construct an improved hitting set for ROBPs over a large alphabet.
</p>
</div></details><details><summary>Not-so-abstract (for curious outsiders)</summary><p>                  ‚ö†Ô∏è <em>This summary might gloss over some important details.</em></p><div class="indent"><p>
  A "decision problem" is a problem where the answer is always "yes" or "no," e.g., the problem of determining whether a given number is prime. Suppose there's a randomized algorithm \(A\) that solves some decision problem with high probability using a small amount of memory. Does that automatically mean there's a deterministic algorithm that solves the same problem using a similar amount of memory? In other words, is it always possible to "derandomize" any low-memory decision algorithm? Computer scientists think so, but we're not sure how to prove it.
</p>

<p>
  If \(A\) has the special feature that it never gives false positives, derandomization is potentially easier. Some of the most promising approaches treat \(A\) as a "black box," meaning that the deterministic algorithm would just simulate \(A\) in a few carefully crafted scenarios and then figure out the correct answer based on what \(A\) outputs in those scenarios. In this paper, we prove that <em>if</em> it is possible to derandomize all low-memory decision algorithms that never give false positives in a black-box manner, then it is possible to derandomize all low-memory decision algorithms, whether they give false positives or not.
</p>
</div></details><p>A manuscript was first posted online in February 2020; the paper was presented at CCC in July 2020. The CCC proceedings version and the ECCC version are the same except for formatting.</p><hr><p>Expository material:</p><div class="expository">
  <iframe src="https://www.youtube.com/embed/5CX1qaF5q4A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  <p>
    <a href="https://www.youtube.com/watch?v=5CX1qaF5q4A">[Video]</a> My prerecorded presentation for CCC (July 2020). Here are the <a href="CCC-slides.pptx">slides</a> from that presentation.
  </p>
  <a href="https://doi.org/10.26153/tsw/15500"><div class="emoji-img">üéì</div></a>
  <p>
    The main result of the paper is explained in <a href="https://doi.org/10.26153/tsw/15500">my PhD dissertation</a> (Section 3.3).
  </p>
  <a href="https://drive.google.com/file/d/13KFoyY6D57SkDWlo0GHgWe14kkL06Z5i/view"><div class="emoji-img">üë®‚Äçüè´</div></a>
  <p>
    The main result of the paper is covered in <a href="https://drive.google.com/file/d/13KFoyY6D57SkDWlo0GHgWe14kkL06Z5i/view">these lecture notes</a> for a course taught by Avishay Tal (Fall 2021).
  </p>
</div>
<hr> <p>What others think:</p><ul><li>This paper was invited to the Theory of Computing special issue for CCC 2020.</li></ul> </article></main><script data-goatcounter="https://williamhoza.goatcounter.com/count" src="//gc.zgo.at/count.js" async=""></script></body></html>