<p>
This is a survey of unconditional <em>pseudorandom generators</em> (PRGs). A PRG uses a short, truly random seed to generate a long, "pseudorandom" sequence of bits. To be more specific, for each restricted model of computation (e.g., bounded-depth circuits or read-once branching programs), we would like to design a PRG that "fools" the model, meaning that every function computable in the model behaves approximately the same when we plug in pseudorandom bits from the PRG as it does when we plug in truly random bits. In this survey, we discuss four major paradigms for designing PRGs:
</p>

<ol>
  <li>We present several PRGs based on $k$-wise uniform generators, small-bias generators, and simple combinations thereof, including proofs of Viola's theorem on fooling low-degree polynomials (Comput. Complexity 2009) and Braverman's theorem on fooling $\mathbf{AC}^0$ circuits (J. ACM 2010).</li>
  <li>We present several PRGs based on "recycling" random bits to take advantage of communication bottlenecks, such as the Impagliazzo-Nisan-Wigderson generator (STOC 1994).</li>
  <li>We present connections between PRGs and computational hardness, including the Nisan-Wigderson framework for converting a hard Boolean function into a PRG (J. Comput. Syst. Sci. 1994).</li>
  <li>We present PRG frameworks based on random restrictions, including the "polarizing random walks" framework (Chattopadhyay, Hatami, Hosseini, and Lovett, Theory Comput. 2019).</li>
</ol>

<p>
  We explain how to use these paradigms to construct PRGs that work <em>unconditionally</em>, with no unproven mathematical assumptions. The PRG constructions use ingredients such as finite field arithmetic, expander graphs, and randomness extractors. The analyses use techniques such as Fourier analysis, sandwiching approximators, and simplification-under-restrictions lemmas.
</p>
