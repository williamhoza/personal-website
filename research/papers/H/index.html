<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><script src="/mathjax-config.js"></script><script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async=""></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Quantum Communication-Query Tradeoffs</title><link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700&amp;display=swap" rel="stylesheet"><link rel="stylesheet" href="/main.css"><meta property="og:title" content="Quantum Communication-Query Tradeoffs"></head><body><span style="display:none;">
      \(\renewcommand{\epsilon}{\varepsilon}\)
      \(\renewcommand{\hat}{\widehat}\)
      \(\DeclareMathOperator*{\E}{\mathbb{E}}\)
    </span><main><article><p><a href="/research/">Back to list of papers</a></p><hr><h1>Quantum Communication-Query Tradeoffs</h1><p>By William M. Hoza</p><hr><p>Read the paper: <a href="https://arxiv.org/abs/1703.07768">arXiv</a></p><details><summary>Abstract (for specialists)</summary><div class="indent"><p>
  For any function \(f \colon X \times Y \to Z\), we prove that
  \[
    Q^{*\text{cc}}(f) \cdot Q^{\text{OIP}}(f) \cdot (\log Q^{\text{OIP}}(f) + \log |Z|) \geq \Omega(\log |X|).
  \]
  Here, \(Q^{*\text{cc}}(f)\) denotes the bounded-error communication complexity of \(f\) using an entanglement-assisted two-way qubit channel, and \(Q^{\text{OIP}}(f)\) denotes the number of quantum queries needed to learn \(x\) with high probability given oracle access to the function \(f_x(y) \stackrel{\text{def}}{=} f(x, y)\). We show that this tradeoff is close to the best possible. We also give a generalization of this tradeoff for <em>distributional</em> query complexity.
  
  As an application, we prove an optimal \(\Omega(\log q)\) lower bound on the \(Q^{*\text{cc}}\) complexity of determining whether \(x + y\) is a perfect square, where Alice holds \(x \in \mathbb{F}_q\), Bob holds \(y \in \mathbb{F}_q\), and \(\mathbb{F}_q\) is a finite field of odd characteristic. As another application, we give a new, simpler proof that searching an ordered size-\(N\) database requires \(\Omega(\log N / \log \log N)\) quantum queries. (It was already known that \(\Theta(\log N)\) queries are required.)
</p>
</div></details><details><summary>Not-so-abstract (for curious outsiders)</summary><p>                  ⚠️ <em>This summary might gloss over some important details.</em></p><div class="indent"><p>
  Quantum algorithms are algorithms that exploit quantum effects, requiring special hardware that, broadly speaking, nobody has managed to build yet. In this paper, we study quantum algorithms for two types of problems. In the first type of problem, Alice has some data \(x\), Bob has some data \(y\), and the two of them would like to figure out whether the pair \((x, y)\) has some property \(P\) using as little communication as possible. For example, maybe \(x\) and \(y\) are numbers between 1 and a million, and \(P\) is the property that \(x > y\). The second type of problem is similar to the game 20 Questions. Alice chooses \(x\). If Bob specifies \(y\), then Alice tells him whether \((x, y)\) has property \(P\). Bob's goal is to learn \(x\) by making as few queries as possible. We prove that if the same property \(P\) is used to formulate each problem, then the two problems can't both have extremely efficient quantum algorithms.
</p>
</div></details><p>I posted a manuscript online in March 2017. </p><hr>  </article></main><script data-goatcounter="https://williamhoza.goatcounter.com/count" src="//gc.zgo.at/count.js" async=""></script></body></html>