<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<link href="/temml/Temml-Latin-Modern.css" rel="stylesheet"/>
<script src="/temml/temml.min.js"></script>
<script src="/temml/auto-render.min.js"></script>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>
Paradigms for Unconditional Pseudorandom Generators
</title>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,700&amp;display=swap" rel="stylesheet"/>
<link href="/main.css" rel="stylesheet"/>
<link href="/research/papers.css" rel="stylesheet"/>
</head>
<body>
<main>
<article>
<p>
<a href="/research/">
            Back to list of papers
          </a>
</p>
<hr/>
<h1>
Paradigms for Unconditional Pseudorandom Generators
</h1>
<p>
Survey paper by Pooya Hatami and William M. Hoza
</p>
<hr/>
<p>
          Read the paper: <a href="fnt-tcs.pdf">FnT TCS</a> • <a href="https://eccc.weizmann.ac.il/report/2023/019/">ECCC</a>
</p>
<details>
<summary>Abstract (for specialists)</summary>
<div class="indent">
<p>
    This is a survey of unconditional <em>pseudorandom generators</em> (PRGs). A PRG uses a short, truly random seed to generate a long, "pseudorandom" sequence of bits. To be more specific, for each restricted model of computation (e.g., bounded-depth circuits or read-once branching programs), we would like to design a PRG that "fools" the model, meaning that every function computable in the model behaves approximately the same when we plug in pseudorandom bits from the PRG as it does when we plug in truly random bits. In this survey, we discuss four major paradigms for designing PRGs:
    </p>
<ol>
<li>We present several PRGs based on $k$-wise uniform generators, small-bias generators, and simple combinations thereof, including proofs of Viola's theorem on fooling low-degree polynomials (Comput. Complexity 2009) and Braverman's theorem on fooling $\mathbf{AC}^0$ circuits (J. ACM 2010).</li>
<li>We present several PRGs based on "recycling" random bits to take advantage of communication bottlenecks, such as the Impagliazzo-Nisan-Wigderson generator (STOC 1994).</li>
<li>We present connections between PRGs and computational hardness, including the Nisan-Wigderson framework for converting a hard Boolean function into a PRG (J. Comput. Syst. Sci. 1994).</li>
<li>We present PRG frameworks based on random restrictions, including the "polarizing random walks" framework (Chattopadhyay, Hatami, Hosseini, and Lovett, Theory Comput. 2019).</li>
</ol>
<p>
      We explain how to use these paradigms to construct PRGs that work <em>unconditionally</em>, with no unproven mathematical assumptions. The PRG constructions use ingredients such as finite field arithmetic, expander graphs, and randomness extractors. The analyses use techniques such as Fourier analysis, sandwiching approximators, and simplification-under-restrictions lemmas.
    </p>
</div>
</details>
<details>
<summary>Not-so-abstract (for curious outsiders)</summary>
<p>⚠️ <em>This summary might gloss over some important details.</em></p>
<div class="indent" value="NOT-SO-ABSTRACT">
<p>
    A "pseudorandom generator" is an algorithm that makes a few coin tosses and outputs a long sequence of bits that "appear random" in some sense. To be more specific, in the context of complexity theory, we want the output bits to appear random to any "sufficiently efficient" observer. This is expository work that describes techniques for designing pseudorandom generators.
  </p>
</div>
</details>
<details><summary>Table of contents</summary><div class="indent toc" value="TOC">
<ol>
<li>
<a href="fnt-tcs.pdf#page=3"><span>Introduction</span></a>
<ol>
<li><a href="fnt-tcs.pdf#page=5"><span>Whom Shall We Fool? Three Approaches to PRGs</span></a></li>
<li><a href="fnt-tcs.pdf#page=10"><span>Overview of this Text</span></a></li>
<li><a href="fnt-tcs.pdf#page=11"><span>The Generic Probabilistic Existence Proof</span></a></li>
<li><a href="fnt-tcs.pdf#page=12"><span>Explicitness</span></a></li>
<li><a href="fnt-tcs.pdf#page=15"><span>Applications of PRGs</span></a></li>
<li><a href="fnt-tcs.pdf#page=22"><span>Beyond PRGs: Hitting Set Generators and More</span></a></li>
</ol>
</li>
<li>
<a href="fnt-tcs.pdf#page=25"><span>Limited Independence and Small-Bias Generators</span></a>
<ol>
<li><a href="fnt-tcs.pdf#page=25"><span>Limited Independence</span></a></li>
<li><a href="fnt-tcs.pdf#page=32"><span>Small-bias Distributions</span></a></li>
<li><a href="fnt-tcs.pdf#page=36"><span>Analysis Technique: Fourier $L_1$ Bounds</span></a></li>
<li><a href="fnt-tcs.pdf#page=43"><span>Viola's Generator for Low-degree $\mathbb{F}_2$-polynomials</span></a></li>
<li><a href="fnt-tcs.pdf#page=51"><span>Analysis Technique: Sandwiching Approximators</span></a></li>
<li><a href="fnt-tcs.pdf#page=58"><span>Braverman's Theorem: Limited Independence Fools $\mathbf{AC}^0$</span></a></li>
</ol>
</li>
<li>
<a href="fnt-tcs.pdf#page=69"><span>Recycling Random Bits</span></a>
<ol>
<li><a href="fnt-tcs.pdf#page=69"><span>PRGs for Two-party Communication Protocols</span></a></li>
<li><a href="fnt-tcs.pdf#page=75"><span>The INW Generator for Standard-order ROBPs</span></a></li>
<li><a href="fnt-tcs.pdf#page=79"><span>The BRRY Generator for Standard-order Regular ROBPs</span></a></li>
<li><a href="fnt-tcs.pdf#page=88"><span>The Nisan-Zuckerman Generator for Short, Wide ROBPs</span></a></li>
</ol>
</li>
<li>
<a href="fnt-tcs.pdf#page=96"><span>PRGs and Hardness</span></a>
<ol>
<li><a href="fnt-tcs.pdf#page=97"><span>PRGs as High-quality Lower Bounds</span></a></li>
<li><a href="fnt-tcs.pdf#page=101"><span>The Nisan-Wigderson Framework</span></a></li>
<li><a href="fnt-tcs.pdf#page=108"><span>Hardness-based PRGs beyond Nisan-Wigderson</span></a></li>
</ol>
</li>
<li>
<a href="fnt-tcs.pdf#page=112"><span>Random Restrictions</span></a>
<ol>
<li><a href="fnt-tcs.pdf#page=114"><span>PRGs from Polarizing Random Walks</span></a></li>
<li><a href="fnt-tcs.pdf#page=128"><span>Analysis Technique: Fourier Growth Bounds</span></a></li>
<li><a href="fnt-tcs.pdf#page=141"><span>Fooling $\mathbf{AC}^0$ via the Ajtai-Wigderson Framework</span></a></li>
<li><a href="fnt-tcs.pdf#page=147"><span>The Forbes-Kelley Generator for ROBPs</span></a></li>
<li><a href="fnt-tcs.pdf#page=155"><span>PRGs for Read-once CNFs via Early Termination</span></a></li>
<li><a href="fnt-tcs.pdf#page=163"><span>Fooling General Branching Programs via the IMZ Framework</span></a></li>
</ol>
</li>
<li>
<a class="no-counter" href="fnt-tcs.pdf#page=172">Acknowledgements</a>
</li>
<li>
<a class="no-counter" href="fnt-tcs.pdf#page=173">Appendices</a>
</li>
<li>
<a class="no-counter" href="fnt-tcs.pdf#page=174">A. Converse of the Sandwiching Lemma</a>
</li>
<li>
<a class="no-counter" href="fnt-tcs.pdf#page=178">B. List of PRGs</a>
</li>
<li>
<a class="no-counter" href="fnt-tcs.pdf#page=184">References</a>
</li>
</ol>
</div></details>
<p>

  We posted a manuscript online in March 2023; the survey was published in Foundations and Trends in Theoretical Computer Science in February 2024. You can download a pdf <a href="fnt-tcs.pdf">here</a>, or you can buy a physical book <a href="https://doi.org/10.1561/0400000109">here</a>. The preliminary version of the survey was titled "Theory of Unconditional Pseudorandom Generators." Besides the title change, the published version has some additional introductory material and various minor improvements.

</p>

<hr/>



</article>
</main>
<script src="/temml/call-auto-render.js"></script>
<script async="" data-goatcounter="https://williamhoza.goatcounter.com/count" src="//gc.zgo.at/count.js"></script>
</body>
</html>